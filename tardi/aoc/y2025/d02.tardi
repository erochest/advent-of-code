
uses: ../io
uses: std/io
uses: std/hashmaps
uses: std/math
uses: std/strings
uses: std/vectors

exports:
  parse-ranges
  [..]
  flatten
  duplicating?
  part1
  ||
  at-end?
  chunk-on
  safe-all?
  repeating?
  part2 ;

// TODO: benchmark and optimize. this takes for-ev-er on the real data

: strip-line-end     "\n" strip-end "\r" strip-end ;     /// str -- str
: split-ranges       "," split-all ;                     /// str -- vector
: parse-range-pair   "-" split-all [ parse-int ] map ;   /// str -- pair/int

/// str -- vector/pair/int
: parse-ranges
    strip-line-end
    split-ranges
    [ parse-range-pair ] map ;

: more?       2dup >= ;               /// a max current -- a max current ?
: store       [ pick push! ] keep ;   /// accum m current -- accum' m current
/// from to -- vector
: [..]
    { } spin
    [ more? ] [ store 1+ ] while
    2drop ;

: bisect     dup strings/length 2 / split-at ;   /// str -- str str
: duplicating?   >string bisect == ;                 /// n -- ?

/// vector/vector -- vector
: flatten   { } [ concat ] reduce ;

/// str -- vector/int
: parse-and-expand
    "parsing ranges" println
    parse-ranges
    "expanding ranges" println
    [ first2 [..] ] map
    "flattening vectors" println
    flatten ;

/// data/str -- checksum/int
: part1
    parse-and-expand
    "identifying duplicating IDs" println
    [ duplicating? ] filter
    "summing" println
    sum ;

/// -- checksum/int
: run-sample-1   2025 02 read-sample-data part1 ;
: run-data-1     2025 02 read-data        part1 ;

///////////////////////////

/// lambda1 lambda2 -- ?
: ||
    [ apply ] dip swap
    [
        drop #t
    ] [
        apply
    ] if ;

/// str|#f -- ?
: at-end?
    [
        dup #f ==
        dup [ nip ] when
    ] [ strings/empty? ] || ;

/// str n -- vector/str
: chunk-on
    { } -rot
    [ over at-end? ! ] [
        [
            split-at
            [ over push! ] dip
        ] keep
    ] while
    2drop ;

/// vector predicate -- ?
: safe-all?
    swap #t
    [
        -rot
        [ [ apply ] keep ] dip
        rot and
    ] reduce
    nip ;

/// vector predicate -- ?
: any?
    swap #f
    [
        -rot
        [ [ apply ] keep ] dip
        rot or
    ] reduce
    nip ;

/// n -- ?
: repeating?
    >string
    dup strings/length 2 / 1 swap [..]
    [ dupd chunk-on ] map nip
    [
        [ first ] keep
        [ dupd == ] safe-all?
        nip
    ] any? ;

/// data/str -- checksum/int
: part2
    parse-and-expand
    "identifying repeating IDs" println
    [ repeating? ] filter
    "summing" println
    sum ;

/// -- checksum/int
: run-sample-2   2025 02 read-sample-data part2 ;
: run-data-2     2025 02 read-data        part2 ;

// run-sample-1 .
// run-data-1 .
// run-sample-2 .
// run-data-2 .
