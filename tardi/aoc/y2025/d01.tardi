
uses: ../io
uses: std/io
uses: std/hashmaps
uses: std/math
uses: std/strings
uses: std/vectors

exports:
  mod
  left right
  do-pair
  zero? count-zero
  accum-dial
  parse-input ??? part1 run-data-1
  left-zeros right-zeros
  do-pair-zero accum-dial-zero
  ???-??? moar-profit part2
  debug ;

// `mod` not built in yet :facepalm:
/// x y -- x%y
: mod
    [ 2dup >= ] [
        [ - ] keep
    ] while
    drop ;

/// value -- value'
: full-spins   [ dup 100 > ] [ 100 - ] while ;

/// dial n -- dial'
: left
    full-spins
    [ 100 + ] dip - abs
    100 mod ;

/// dial n -- dial'
: right
    full-spins
    +
    100 mod ;

/// line -- pair
: parse-line
    1 split-at
    parse-int
    2vector ;

/// data/str -- xs
: parse-input   lines [ parse-line ] map ;

/// n line-pair -- n'
: do-pair
    first2 swap
    "L" ==
    [ left ] [ right ] if ;

// TODO: std/math
/// n -- ?
: zero?   0 == ;

/// count n -- count' n
: count-zero   zero? [ 1+ ] when ;

/// history pair -- history'
: accum-dial
    [ dup last ] dip
    do-pair
    over push! ;

/// pairs -- dial-settings
: ???   { 50 } [ accum-dial ] reduce ;

/// ys -- checksum/int
: profit   [ zero? ] filter vectors/length ;

// TODO: std/vectors
/// xs n -- xs'
: lastn
    over vectors/length
    swap dupd - dup
    0 <= [ 2drop ] [
        spin subvector
    ] if ;

: print-col   "\t" print dup print ;

/// lines -- zero-count
: debug
    { 50 } [
        // log line -- log'
        dup print
        parse-line
        print-col
        accum-dial
        dup 10 lastn print-col
        last zero? print-col
        nl drop
    ] reduce
    profit ;

/// data/str -- checksum/int
: part1   parse-input ??? profit ;

/// -- checksum/int
: run-sample-1   2025 01 read-sample-data part1 ;
: run-data-1     2025 01 read-data        part1 ;

// run-data-1 .
// 2025 01 read-data lines debug
// 2025 01 read-sample-data lines debug

///////////////////////////

/// dial n -- dial' zero-count
: left-zeros
    [ dup zero? [ drop 100 ] when ] dip
    - 0
    [ over 0 < ] [
        [ 100 + ] dip 1+
    ] while
    [ 100 mod ] dip
    over zero? [ 1+ ] when
;

/// dial n -- dial' zero-count
: right-zeros
    + 0
    [ over 100 > ] [
        [ 100 - ] dip 1+
    ] while
    [ 100 mod ] dip
    over zero? [ 1+ ] when
;

/// dial line-pair -- dial-zero
: do-pair-zero
    first2 swap
    "L" ==
    [ left-zeros ] [ right-zeros ] if
    2vector ;

/// log pair -- log'
: accum-dial-zero
    [ dup last first ] dip
    do-pair-zero
    over push! ;

/// lines -- zero-clicks
: ???-???   { { 50 0 } } [ accum-dial-zero ] reduce ;

/// zero-clicks -- checksum
: moar-profit   [ second ] map sum ;

/// lines -- zero-count
: debug-zero
        { { 50 0 } } [
        // log line -- log'
        dup print
        parse-line
        print-col
        accum-dial-zero
        dup 10 lastn print-col
        nl drop
    ] reduce
    moar-profit ;

/// data/str -- checksum/int
: part2   parse-input ???-??? moar-profit ;

/// -- checksum/int
: run-sample-2   2025 01 read-sample-data part2 ;
: run-data-2     2025 01 read-data        part2 ;

// 2025 01 read-sample-data lines debug-zero
run-data-2
