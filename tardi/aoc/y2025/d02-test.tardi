uses: ../io
uses: ../testing
uses: std/io
uses: std/strings
uses: std/vectors
uses: ./d02


"parse-ranges should parse ranges"
"11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124\n"
parse-ranges
{
  { 11 22 } { 95 115 } { 998 1012 } { 1188511880 1188511890 } { 222220 222224 } { 1698522 1698528 }
  { 446443 446449 } { 38593856 38593862 } { 565653 565659 } { 824824821 824824827 } { 2121212118 2121212124 }
} assert==

"[..] expands a range"
{ 11 22 } first2 [..]
{ 11 12 13 14 15 16 17 18 19 20 21 22 } assert==

"duplicating? should find numbers that repeat twice: 55"
55 duplicating? #t assert==

"duplicating? should find numbers that repeat twice: 6464"
6464 duplicating? #t assert==

"duplicating? should find numbers that repeat twice: 123123"
123123 duplicating? #t assert==

"duplicating? should not find numbers that do not repeat: 95"
95 duplicating? #f assert==

"duplicating? should not find numbers that do not repeat: 995"
995 duplicating? #f assert==

"flatten should do nothing with empty vectors"
{ } flatten { } assert==

"flatten should concatenate two internal vectors: simple"
{ { 1 } { 2 } } flatten { 1 2 } assert==

"flatten should concatenate two internal vectors: many"
{ { 1 } { 2 } { 3 } } flatten { 1 2 3 } assert==

"flatten should concatenate two internal vectors: different lengths"
{ { 1 2 } { 3 4 } { 5 } } flatten { 1 2 3 4 5 } assert==

"flatten should concatenate two internal vectors: empty subvectors"
{ { 1 } { } { 2 } } flatten { 1 2 } assert==

"part1 sample should return 1227775554"
2025 02 read-sample-data part1
1227775554 assert==

"|| returns true if first is true"
[ #t ] [ #t ] || #t assert==

"|| returns true if second is true"
[ #f ] [ #t ] || #t assert==

"|| returns false if neither is true"
[ #f ] [ #f ] || #f assert==

"at-end? recognizes #f"
#f at-end? #t assert==

"at-end? recognizes \"\""
"" at-end? #t assert==

"at-end? does not recognize non-empty strings "
"not at end" at-end? #f assert==

"chunk-on returns empty vector with empty string"
"" 2 chunk-on
{ } assert==

"chunk-on returns singleton vector with chunk-sized string"
"ab" 2 chunk-on
{ "ab" } assert==

"chunk-on chunks string into vector"
"ababab" 2 chunk-on
{ "ab" "ab" "ab" } assert==

"chunk-on chunks string with non-even size"
"abcabcabc" 3 chunk-on
{ "abc" "abc" "abc" } assert==

"chunk-on chunks string with trailing characters"
"abcabcabcde" 3 chunk-on
{ "abc" "abc" "abc" "de" } assert==

"repeating? should find duplicates ranges"
12341234 repeating? #t assert==

"repeating? should find triplicates ranges"
123123123 repeating? #t assert==

"repeating? should find many repeats: 1212121212"
1212121212 repeating? #t assert==

"repeating? should find many repeats: 1111111"
1111111 repeating? #t assert==

"repeating? should not find numbers that do not repeat: 95"
95 repeating? #f assert==

"repeating? should not find numbers that do not repeat: 995"
995 repeating? #f assert==

"safe-all? combines simple tests"
{ "a" "bx" "c" } [ strings/length 1 == ] safe-all?
{ "a" "b" "c" } [ strings/length 1 == ] safe-all?
2vector
{ #f #t } assert==

"safe-all? works with predicates that look at the rest of the stack"
"a" { "a" "a" "a" } [ dupd == ] safe-all? nip
"a" { "a" "b" "a" } [ dupd == ] safe-all? nip
2vector
{ #t #f } assert==

"part2 sample should return 1227775554"
2025 02 read-sample-data part2
4174379265 assert==
