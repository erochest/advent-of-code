
// uses: std/io uses: std/strings uses: std/vectors uses: ./aoc/y2024/io uses: ./aoc/y2024/d02

uses: ./io
uses: std/io
uses: std/strings
uses: std/vectors

exports:
  parse ??? profit
  safe? filter tri all-in-range? all-ascending? all-descending?
  all? negative? positive? or and find-deltas window-pairs
  part1 part2 ;


/// string -- vector/vector/int
: parse-level    parse-int ;
: parse-report   split-whitespace [ parse-level ] map ;
: parse          lines [ parse-report ] map ;

: first2    [ first ] [ second ] bi ;   /// {xy} -- x y
: 1vector   { } [ push! ] keep ;       /// x -- {x}

: #f?   #f == ;   /// x -- ?

: window/setup    #f { } rot ;           /// v -- ? accum v
: window/first?   swapd over #f? ;       /// prev accum x -- accum prev i ?
: window/store    nip swap ;             /// accum prev current -- current accum 
: window/pair     2vector over push! ;   /// accum prev current -- accum

/// vector -- vector/vector
: window-pairs
    window/setup
    [
        window/first? [
            window/store
        ] [
            [ window/pair ] keep
            swap
        ] if
    ] each
    nip ;

/// vector/vector -- vector
: find-deltas       window-pairs [ first2 - ] map ;

: and               [ [ #t ] [ #f ] if ] [ drop #f ] if ;
: or                [ drop #t ] [ [ #t ] [ #f ] if ] if ;
: positive?         0 > ;
: negative?         0 < ;
: all?              swap #t [ pick apply and ] reduce nip ;

: all-ascending?    [ positive? ] all? ;
: all-descending?   [ negative? ] all? ;

// TODO: std
: abs   dup 0 < [ -1 * ] when ;   /// x -- x'

: and-over   [ reach >= and ] keep ;   /// min x accum item -- min x accum' item
: and-under  pick < and ;              /// max accum item -- max accum'

/// xs min max -- ?
: all-in-range?
    rot #t [
        abs
        and-over
        and-under
    ] reduce
    [ 2drop ] dip ;

: tri1   [ apply ] 2dip ;       /// x q _ _ -- x'
: tri2   -rot [ apply ] dip ;   /// q _ x   -- x'
: tri3   swap apply ;           /// q x     -- x'

// TODO: std
/// x p q r --
: tri
    reach >r
    tri1
    r@ tri2
    r> tri3 ;

// TODO: std
: filter?    [ pick apply ] keep swap ;      /// pred accum i -- pred accum i ?
: push-if!   [ over push! ] [ drop ] if ;    /// xs x ?       -- xs'
: (filter)   [ filter? push-if! ] reduce ;   /// p xs accum -- p accum
: filter     swap { } (filter) nip ;         /// xs p -- xs'

: safe?
    [ all-ascending? ]
      [ all-descending? ]
      [ find-deltas 1 3 all-in-range? ] tri
    [ or ] dip and ;

/// vector/vector/int -- vector'/vector/int
: ???               [ safe? ] filter ;

/// vector -- checksum
: profit   length ;

: part1    parse ??? profit ;      /// string -- checksum

: part2 ;

/////////////////////////

2024 2 read-sample-data

"Sample Part 1: " print
part1 println

/////////////////////////

2024 2 read-data

"Data Part 1: " print
part1 println
