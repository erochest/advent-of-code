uses: ./io
uses: std/io
uses: std/strings
uses: std/vectors
uses: ./d02

// TODO: std/testing
// TODO: `tardi -m` to run a module
// TODO: find and run test files

// TODO: fail on symbol not found

// TODO: spec-test structures

// TODO: verbose flag to always print outcomes
// TODO: terminal coloring -- green and red
// TODO: set exit status
/// ? msg --
: test-output
    over [
        2drop
    ] [
        print
        ": " print
        .
    ] if ;

// TODO: how to abstract this out? maybe need assert!= and others
// TODO: take expected stack and a lambda. print lambda on failing
/// message expected actual ? --
: verbose-assert==
      [ [ >string ] bi@ ] dip   // >string
      [ print ] 3dip            // message
      ": " print
      [ print ] 2dip            // expected
      " == " " != " ? print     // ==/!=
      println ;                 // actual
/// message expected actual ? --
: quiet-assert==
    [ 3drop ] [ #f verbose-assert== ] if ;

/// message expected actual --
// : assert==   2dup == verbose-assert== ;
: assert==   2dup == quiet-assert== ;

"parse should parse input"
{ { 7 6 4 2 1 }
  { 1 2 7 8 9 }
  { 9 7 6 2 1 }
  { 1 3 2 4 5 }
  { 8 6 4 4 1 }
  { 1 3 6 7 9 } }
2024 2 read-sample-data parse
assert==

"first2 should leave first two items of a vector on the stack"
#t
{ 7 8 } first2
8 == swap 7 == and
assert==

"#f? should return true for false" #t #f #f? assert==
"#f? should return false for 0   " #f 0  #f? assert==
"#f? should return false for true" #f #t #f? assert==

"window-pairs should return empty list for empty input"
{ } { } window-pairs assert==
"window-pairs should return one window for a two-item list"
{ { 1 2 } } { 1 2 } window-pairs assert==
"window-pairs should return two windows for a three-item list"
{ { 1 2 } { 2 3 } } { 1 2 3 } window-pairs assert==
"window-pairs should return three windows for a four list"
{ { 1 2 } { 2 3 } { 3 4 } } { 1 2 3 4 } window-pairs assert==

"find-delta returns difference between each two items" { 1 1 2 } { 1 2 3 5 } find-deltas assert==
"find-delta returns negative differences"
{ 1 -1 7 -5 } { 2 3 2 9 4 } find-deltas assert==

"and #t #t" #t #t #t and assert==
"and #f #t" #f #f #t and assert==
"and #t #f" #f #t #f and assert==
"and #f #f" #f #f #f and assert==

"or #t #t" #t #t #t or assert==
"or #f #t" #t #f #t or assert==
"or #t #f" #t #t #f or assert==
"or #f #f" #f #f #f or assert==

"positive? #t on >0" #t  1 positive? assert==
"positive? #f on <0" #f -1 positive? assert==
"positive? #f on =0" #f  0 positive? assert==

"negative? #f on >0" #f  1 negative? assert==
"negative? #t on <0" #t -1 negative? assert==
"negative? #f on =0" #f  0 negative? assert==

"all? #t on empty list" #t { } [ 0 == ] all? assert==
"all? #t if all items match predicate" #t { 1 2 3 } [ positive? ] all? assert==
"all? #f if no items match predicate" #f { 1 2 3 } [ negative? ] all? assert==
"all? #t if one item does not match predicate" #f { 1 -2 3 } [ positive? ] all? assert==

"safe? #f if sequences goes up and down" #f { 1 2 3 1 4 } safe? assert==

"partition finds all trues"
{ { } { 1 2 3 4 } }
{ 1 2 3 4 } [ positive? ] partition 2vector
assert==

"partition finds all falses"
{ { 1 2 3 4 } { } }
{ 1 2 3 4 } [ negative? ] partition 2vector
assert==

"partition divides its input list"
{ { 0 -3 -5 } { 1 2 4 } }
{ 0 1 2 -3 4 -5 } [ positive? ] partition 2vector
assert==

"part2 calculates expanded safe rows"
4
2024 2 read-sample-data part2
assert==

"dampener-safe? finds unsafe levels"
#f
{ 1 2 7 8 9 } dampener-safe?
assert==

"dampener-safe? finds unsafe levels"
#f
{ 9 7 6 2 1 } dampener-safe?
assert==

"dampener-safe? finds safe levels"
#t
{ 1 3 2 4 5 } dampener-safe?
assert==

"dampener-safe? finds safe levels"
#t
{ 8 6 4 4 1 } dampener-safe?
assert==

"[..) when passed same value returns empty vector"
{ }
1 1 [..)
assert==

"[..) returns single-item vector"
{ 1 }
1 2 [..)
assert==

"[..) returns range"
{ 1 2 3 4 5 6 }
1 7 [..)
assert==

"[..) when numbers are reversed returns empty vector"
{  }
1 0 [..)
assert==

"remove-at when negative index does nothing"
{ 1 2 3 }
{ 1 2 3 } -1 remove-at
assert==

"remove-at when index beyond length does nothing"
{ 1 2 3 }
{ 1 2 3 } 10 remove-at
assert==

"remove-at removes first item from list"
{ 2 3 }
{ 1 2 3 } 0 remove-at
assert==

"remove-at removes last item from list"
{ 1 2 }
{ 1 2 3 } 2 remove-at
assert==

"remove-at removes from middle of list" 
{ 0 1 3 4 }
{ 0 1 2 3 4 } 2 remove-at
assert==
